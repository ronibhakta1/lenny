
"""
In order to read EPUBs, we use Thorium Web (i.e. our `reader` service)
which speaks in "manifests" generated by the `readium` service:

Once our items are uploaded to, Lenny's `readium` service is
preconfigured w/ `s3` so out-of-the-box it can generate manifests for
_any_ of its book. To do so, you need to query `readium` to produce a
`manifest.json` file for a specified *base64* encoded version of a
full s3 filepath:

* e.g.  `<http://localhost:15080/{base64(filepath)}/manifest.json>` where...
    * the book's full s3 filepath is `<s3://bookshelf/32941311.epub>` 
    * its `base64(filepath)` can be computed using:
        * `echo -n "<s3://bookshelf/32941311.epub>" |  base64 | tr '/+' '_-' | tr -d '='` → `czM6Ly9ib29rc2hlbGYvMzI5NDEzMTEuZXB1Yg`
    ◦ resulting in <http://localhost:15080/czM6Ly9ib29rc2hlbGYvMzI5NDEzMTEuZXB1Yg/manifest.json>
Finally, you can navigate to `http:localhost:3000/read?book={readium_manifest_url}` to read the book
* e.g. `<http:localhost:3000/read?book=http://localhost:15080/czM6Ly9ib29rc2hlbGYvMzI5NDEzMTEuZXB1Yg/manifest.json>`
"""

import httpx
from lenny.core.api import LennyAPI
from lenny.core.utils import encode_book_path
from lenny.core.exceptions import ItemNotFoundError
from lenny.configs import READIUM_BASE_URL
from urllib.parse import quote

class ReadiumAPI:

    @classmethod
    def get_manifest(cls, book_id, format):
        if not LennyAPI.Item.exists(book_id):
            raise ItemNotFoundError(f"Item {book_id} doesn't exist")
        readium_url = cls.make_url(book_id, format, "/manifest.json")
        with httpx.Client(verify=False) as client:
            resp = client.get(readium_url, follow_redirects=True)
            resp.raise_for_status()
            manifest = resp.json()
            return cls.patch_manifest(manifest, book_id)
    
    @classmethod
    def make_url(cls, book_id, format, readium_path):
        ebp = encode_book_path(book_id, format=format)
        # v0.6.0+ uses /webpub prefix for all routes
        readium_url = f"{READIUM_BASE_URL}/webpub/{ebp}/{readium_path}"
        return readium_url

    @classmethod
    def patch_manifest(cls, manifest: dict, book_id: str):
        """Rewrites `self` to link to the correct public url"""
        for i in range(len(manifest['links'])):
            if manifest['links'][i].get('rel') == 'self':
                manifest['links'][i]['href'] = LennyAPI.make_url(
                    f"/v1/api/items/{book_id}/readium/manifest.json"
                )
        encoded_manifest = quote(manifest['links'][i]['href'], safe='')
        manifest['links'][i]['href'] = encoded_manifest
        return manifest
